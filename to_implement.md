# à implémenter

- Knapsack Problem
- Longest Increasing Subsequence
- Timsort 
- Tri par Comparaison Optimal
- Arbres d'intervalles
- Trie (Arbre de préfixe)


Pour devenir fort en algorithmes et en structures de données, il est crucial de maîtriser un large éventail de patterns de problèmes et de structures de données. Voici une vue d'ensemble pour t'aider dans ton parcours.

### Patterns de Problèmes en Algorithmique

1. **Diviser pour régner** : Décompose un problème en sous-problèmes de même nature, résout ces sous-problèmes récursivement, et combine leurs solutions.
2. **Programmation dynamique** : Résout des problèmes complexes en les décomposant en sous-problèmes plus simples, en stockant les résultats des sous-problèmes pour éviter des calculs redondants.
3. **Backtracking** : Explore les solutions potentielles pour trouver une solution à un problème, en revenant en arrière (backtrack) si une impasse est atteinte.
4. **Recherche exhaustive** : Explore systématiquement toutes les possibilités jusqu'à trouver la solution.
5. **Greedy (Glouton)** : Construit une solution étape par étape, choisissant à chaque étape l'option la plus prometteuse sans revenir en arrière.
6. **Recherche binaire** : Réduit de moitié l'espace de recherche à chaque étape, utilisé pour la recherche dans des données triées.
7. **Pointeurs de balayage (Two Pointers)** : Utilise deux pointeurs pour parcourir une structure de données, souvent pour trouver des paires ou des sous-ensembles de données.
8. **Parcours de graphes (DFS/BFS)** : Explore un graphe en profondeur (DFS) ou en largeur (BFS) pour visiter les nœuds ou trouver des chemins.
9. **Topological Sorting (Tri topologique)** : Trie les nœuds d'un graphe dirigé sans cycle selon l'ordre des dépendances.
10. **Algorithme de Dijkstra / Bellman-Ford / Floyd-Warshall** : Trouve le chemin le plus court dans un graphe, avec des variantes pour les graphes avec ou sans poids négatifs.
11. **Union-Find** : Gère une collection d'ensembles disjoints pour des opérations telles que l'union et la recherche, utile pour détecter les cycles dans un graphe.
12. **Hashing** : Utilise des fonctions de hachage pour une recherche rapide, une insertion et une suppression des données.
13. **Bit Manipulation** : Utilise des opérations sur les bits pour résoudre des problèmes de manière efficace.

### Structures de Données Essentielles

1. **Tableaux et Chaînes de caractères**
2. **Listes liées**
3. **Piles et Files**
4. **Tables de hachage**
5. **Arbres (y compris BST, AVL, Arbres rouges-noirs)**
6. **Tas (Min-Heap, Max-Heap)**
7. **Graphes (représentés par des listes d'adjacence ou des matrices d'adjacence)**
8. **Structures de données avancées comme les arbres de segments, les arbres de Fenwick (Binary Indexed Trees), et les Trie (arbres de préfixe) pour des cas d'utilisation spécifiques.**

Maîtriser ces patterns de problèmes et structures de données te donnera une base solide pour aborder la plupart des problèmes algorithmiques. Chacun de ces domaines comporte des nuances et des variantes, et l'apprentissage se fait le mieux à travers la pratique et l'application de ces concepts à de véritables problèmes de programmation. Participer à des compétitions de codage et résoudre des problèmes sur des plateformes en ligne peut être un excellent moyen de renforcer ces compétences.